#include <stdio.h>
#include <wolfssl/options.h>
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/random.h>
#include <wolfssl/wolfcrypt/cryptocb.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/wolfcrypt/logging.h>

#define WOLFSSL_TROPIC01
#include <wolfssl/wolfcrypt/port/tropicsquare/tropic01.h>

#define RNG_SIZE 32  // 256-bit random output


int main(void)
{
    int ret;
    WC_RNG rng;
    Aes aes[1]; // Array to hold AES context
    byte aes_key[WC_AES_BLOCK_SIZE] = {0x00, 0x01, 0x02, 0x03, 
                                        0x04, 0x05, 0x06, 0x07,
                                        0x08, 0x09, 0x0A, 0x0B,
                                        0x0C, 0x0D, 0x0E, 0x0F}; // Example AES key
    byte iv[WC_AES_BLOCK_SIZE] = {0x00, 0x01, 0x02, 0x03,   
                                  0x04, 0x05, 0x06, 0x07,
                                  0x08, 0x09, 0x0A, 0x0B,
                                  0x0C, 0x0D, 0x0E, 0x0F}; // Example IV
    byte msg[WC_AES_BLOCK_SIZE] = {0x01, 0x02, 0x03, 0x04, 
                                    0x05, 0x06, 0x07, 0x08,
                                    0x09, 0x0A, 0x0B, 0x0C,
                                    0x0D, 0x0E, 0x0F, 0x10}; // Example plaintext message
    byte cipher[WC_AES_BLOCK_SIZE]; // Buffer for ciphertext
    byte plain[WC_AES_BLOCK_SIZE]; // Buffer for decrypted plaintext


     
    byte output[RNG_SIZE];

    printf("wolfSSL Crypto Callback Test Application\n");
    printf("========================================\n");
    
    wolfSSL_Debugging_ON(); 
    
    /* wolfCrypt initialization */
    if ((ret = wolfCrypt_Init()) != 0) {
        char error_msg[80];
        wc_ErrorString(ret, error_msg);
        printf("wolfCrypt_Init failed: %s (code %d)\n", error_msg, ret);
        return EXIT_FAILURE;
    }
    printf("wolfCrypt initialized successfully\n");


    /* Register our crypto callback */
    printf("Registering crypto callback with device ID %d...\n", 
           WOLF_TROPIC01_DEVID);
    ret = wc_CryptoCb_RegisterDevice(WOLF_TROPIC01_DEVID, Tropic01_CryptoCb, NULL);
    if (ret != 0) {
        printf("Failed to register crypto callback: %d\n", ret);
        return EXIT_FAILURE;
    }
    printf("Crypto callback registered successfully\n");

    // Initialize RNG
    if ((ret = wc_InitRng_ex(&rng,NULL, WOLF_TROPIC01_DEVID)) != 0) {
        printf("RNG initialization failed: %d\n", ret);
        return 1;
    }

    // Generate random data
    if ((ret = wc_RNG_GenerateBlock(&rng, output, RNG_SIZE)) != 0) {
        printf("RNG generation failed: %d\n", ret);
        wc_FreeRng(&rng);
        return 1;
    }
    
    //wc_GenerateSeed(&rng, output, RNG_SIZE);
    // Print generated bytes
    printf("Generated %d random bytes:\n", RNG_SIZE);
    for (int i = 0; i < RNG_SIZE; i++) {
        printf("%02X", output[i]);
        if ((i+1) % 16 == 0) printf("\n");
        else if ((i+1) % 4 == 0) printf(" ");
    }
    printf("\n");

    // Cleanup
    wc_FreeRng(&rng);
    printf("RNG test completed successfully\n");
    printf("AES test starting:\n");
    ret = wc_AesInit(aes, NULL, WOLF_TROPIC01_DEVID);
    if (ret == 0) {
        ret = wc_AesSetKey(aes, (byte*)aes_key,
        		WC_AES_BLOCK_SIZE, iv, AES_ENCRYPTION);
        if (ret == 0) {
            ret = wc_AesCbcEncrypt(aes, cipher, msg, WC_AES_BLOCK_SIZE);
        }

        wc_AesFree(aes);
    }
    
    return 0;
}
